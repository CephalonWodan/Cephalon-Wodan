import { Alert } from "./Alert-CXEOqvgh.js";
import { Calendar } from "./Calendar-CtzZQXj7.js";
import { CambionCycle } from "./CambionCycle-C6NHUjOU.js";
import { CetusCycle } from "./CetusCycle-DIZdevob.js";
import { ConclaveChallenge } from "./ConclaveChallenge-Dp5yOxVu.js";
import { ConstructionProgress } from "./ConstructionProgress-DfcpaGL5.js";
import { DailyDeal } from "./DailyDeal-BGqZAp-j.js";
import { DarkSector } from "./DarkSector-BQ97_8h6.js";
import { DuviriCycle } from "./DuviriCycle-CmHJStJo.js";
import { EarthCycle } from "./EarthCycle-B9aIOAEY.js";
import { Fissure } from "./Fissure-7yFmOet3.js";
import { FlashSale } from "./FlashSale-BxVI0J6A.js";
import { GlobalUpgrade } from "./GlobalUpgrade-B_TKK1m_.js";
import { Invasion } from "./Invasion-uloHTxoW.js";
import { Kuva } from "./Kuva-DqkxvPUg.js";
import { MidrathCycle } from "./MidrathCycle-DDfT7zVx.js";
import { News } from "./News-7F8Nbp4A.js";
import { Nightwave } from "./Nightwave-DDX0_zJU.js";
import { PersistentEnemy } from "./PersistentEnemy-axYxYzv_.js";
import { Simaris } from "./Simaris-B9Mvso2q.js";
import { Sortie } from "./Sortie-DcoAnEaJ.js";
import { SteelPathOfferings } from "./SteelPathOffering-DyAzr3P9.js";
import { SyndicateMission } from "./SyndicateMission-5PZIEM8P.js";
import { VallisCycle } from "./VallisCycle-BX8yyKx3.js";
import { VoidTrader } from "./VoidTrader-CbLMfEVj.js";
import { WeeklyChallenge } from "./WeeklyChallenge-MzUEZAjv.js";
import { WorldEvent } from "./WorldEvent-nis9w9cn.js";
import { ZarimanCycle } from "./ZarimanCycle-BJ84QUFg.js";
import { DuviriChoice } from "./DuviriChoice-DRNDUbyc.js";
import { Tmp } from "./Tmp-DkQq1arD.js";
import { createHash } from "node:crypto";
import wsData from "warframe-worldstate-data";
import { parseDate } from "warframe-worldstate-data/utilities";

//#region lib/WorldState.ts
const { sortie } = wsData;
const safeArray = (arr) => arr ?? [];
const safeObj = (obj) => obj ?? {};
/**
* Default Dependency object
* @type {Dependency}
*/
const defaultDeps = {
	sortieData: sortie,
	locale: "en",
	logger: console
};
/**
*
* @param ParserClass class for parsing data
* @param dataArray array of raw data
* @param deps shared dependency object
* @param uniqueField field to treat as unique
* @returns  array of parsed objects
*/
function parseArray(ParserClass, dataArray, deps, uniqueField) {
	const arr = (dataArray || []).map((d) => new ParserClass(d, deps));
	if (uniqueField) {
		const utemp = {};
		arr.sort((a, b) => (a.id || "").localeCompare(b.id || ""));
		arr.forEach((obj) => {
			const key = String(obj[uniqueField]);
			utemp[key] = obj;
		});
		return Array.from(arr).filter((obj) => {
			if (obj?.active && typeof obj.active !== "undefined") return obj.active;
			return true;
		});
	}
	return arr;
}
/**
* Parse array of objects that requires async parsing
* @param ParserClass class for parsing data - must expose a static build method
* @param dataArray array of raw data
* @param deps shared dependency object
* @param uniqueField field to treat as unique
* @returns array of parsed objects
*/
async function parseAsyncArray(ParserClass, dataArray, deps, uniqueField) {
	const arr = [];
	for await (const d of dataArray ?? []) arr.push(await ParserClass.build(d, deps));
	if (uniqueField) {
		const utemp = {};
		arr.sort((a, b) => (a.id ?? "").localeCompare(b.id ?? ""));
		arr.forEach((obj) => {
			const key = String(obj[uniqueField]);
			utemp[key] = obj;
		});
		return Array.from(arr).filter((obj) => {
			if (obj?.active && typeof obj.active !== "undefined") return obj.active;
			return true;
		});
	}
	return arr;
}
/**
* Parses Warframe Worldstate JSON
*/
var WorldState = class WorldState {
	/**
	* The date and time at which the World State was generated
	*/
	timestamp;
	/**
	* Current Warframe version
	*/
	buildLabel;
	/**
	* The in-game news
	*/
	news;
	/**
	* The current events
	*/
	events;
	/**
	* The current alerts
	*/
	alerts;
	/**
	* The current sortie
	*/
	sortie;
	/**
	* The current syndicate missions
	*/
	syndicateMissions;
	/**
	* The current fissures: 'ActiveMissions' & 'VoidStorms'
	*/
	fissures;
	/**
	* The current global upgrades
	*/
	globalUpgrades;
	/**
	* The current flash sales
	*/
	flashSales;
	/**
	* The current invasions
	*/
	invasions;
	/**
	* The state of the dark sectors
	*/
	darkSectors;
	/**
	* The state of all Void Traders
	*/
	voidTraders;
	/**
	* The first entry for voidTraders
	* @deprecated
	*/
	voidTrader;
	/**
	* The current daily deals
	*/
	dailyDeals;
	/**
	* The state of the sanctuary synthesis targets
	*/
	simaris;
	/**
	* The current conclave challenges
	*/
	conclaveChallenges;
	/**
	* The currently active persistent enemies
	*/
	persistentEnemies;
	/**
	* The current earth cycle
	*/
	earthCycle;
	/**
	* The current Cetus cycle
	*/
	cetusCycle;
	/**
	* Cambion Drift Cycle
	*/
	cambionCycle;
	/**
	* The current Zariman cycle based off current time
	*/
	zarimanCycle;
	/**
	* Midrath cycle (soulframe)
	*/
	midrathCycle;
	/**
	* Weekly challenges
	*/
	weeklyChallenges;
	/**
	* The Current construction progress for Fomorians/Razorback/etc.
	*/
	constructionProgress;
	/**
	* The current Orb Vallis cycle state
	*/
	vallisCycle;
	/**
	* The current nightwave season
	*/
	nightwave;
	/**
	* Kuva missions array
	*/
	kuva;
	/**
	* Arbitration mission
	*/
	arbitration;
	/**
	* Current sentient outposts
	*/
	sentientOutposts;
	/**
	* Steel path offering rotation
	*/
	steelPath;
	/**
	* The current prime resurgence
	*/
	vaultTrader;
	/**
	* The current archon hunt
	*/
	archonHunt;
	/**
	* Current Duviri circuit choices
	*/
	duviriCycle;
	/**
	* Current kinepage message
	*/
	kinepage;
	/**
	* The current Deep Archimedea missions and modifiers
	*/
	deepArchimedea;
	/**
	* The current Temporal Archimedea missions and modifiers
	*/
	temporalArchimedea;
	/**
	* The current calendar for 1999
	*/
	calendar;
	/**
	* Generates the worldstate json as a string into usable objects
	*/
	static async build(json, deps = defaultDeps) {
		if (typeof json !== "string") throw new TypeError(`json needs to be a string, provided ${typeof json} : ${JSON.stringify(json)}`);
		const data = JSON.parse(json);
		const ws = new WorldState(data, deps);
		ws.events = await parseAsyncArray(WorldEvent, data.Goals, deps);
		ws.syndicateMissions = await parseAsyncArray(SyndicateMission, data.SyndicateMissions, deps, "syndicate");
		return ws;
	}
	/**
	* @param data The worldstate JSON string
	* @param deps The options object
	*/
	constructor(data, deps = defaultDeps) {
		deps = {
			...defaultDeps,
			...deps
		};
		this.timestamp = /* @__PURE__ */ new Date(data.Time * 1e3);
		this.buildLabel = data.BuildLabel;
		this.news = parseArray(News, safeArray(data.Events).filter((e) => typeof e.Messages.find((msg) => msg.LanguageCode === deps.locale) !== "undefined"), deps);
		this.events = [];
		this.alerts = parseArray(Alert, data.Alerts, deps);
		[this.sortie] = parseArray(Sortie, data.Sorties, deps);
		this.syndicateMissions = [];
		this.fissures = parseArray(Fissure, data.ActiveMissions, deps).concat(parseArray(Fissure, data.VoidStorms, deps));
		this.globalUpgrades = parseArray(GlobalUpgrade, data.GlobalUpgrades, deps);
		this.flashSales = parseArray(FlashSale, data.FlashSales, deps);
		this.invasions = parseArray(Invasion, data.Invasions, deps);
		this.darkSectors = parseArray(DarkSector, data.BadlandNodes, deps);
		this.voidTraders = parseArray(VoidTrader, data.VoidTraders, deps).sort((a, b) => a.activation.getTime() - b.activation.getTime());
		[this.voidTrader] = this.voidTraders;
		this.dailyDeals = parseArray(DailyDeal, data.DailyDeals, deps);
		this.simaris = new Simaris(safeObj(data.LibraryInfo), deps);
		this.conclaveChallenges = parseArray(ConclaveChallenge, data.PVPChallengeInstances, deps);
		this.persistentEnemies = parseArray(PersistentEnemy, data.PersistentEnemies, deps);
		this.earthCycle = new EarthCycle();
		const cetusSynd = safeArray(data.SyndicateMissions).filter((syndicate$1) => syndicate$1.Tag === "CetusSyndicate");
		const bountyEnd = parseDate(cetusSynd.length > 0 ? cetusSynd[0].Expiry : { $date: { $numberLong: 0 } });
		this.cetusCycle = new CetusCycle(bountyEnd);
		this.cambionCycle = new CambionCycle(this.cetusCycle);
		this.zarimanCycle = new ZarimanCycle(bountyEnd);
		this.midrathCycle = new MidrathCycle();
		this.weeklyChallenges = data.WeeklyChallenges ? new WeeklyChallenge(data.WeeklyChallenges) : void 0;
		this.constructionProgress = new ConstructionProgress(data.ProjectPct);
		this.vallisCycle = new VallisCycle();
		if (data.SeasonInfo) this.nightwave = new Nightwave(data.SeasonInfo, deps);
		const externalMissions = new Kuva(deps);
		({kuva: this.kuva, arbitration: this.arbitration} = externalMissions);
		if (!this.arbitration || !Object.keys(this.arbitration).length) this.arbitration = {
			id: createHash("sha256").update("SolNode000", "utf8").digest("hex"),
			node: "SolNode000",
			nodeKey: "SolNode000",
			activation: /* @__PURE__ */ new Date(0),
			expiry: /* @__PURE__ */ new Date(864e13),
			enemy: "Tenno",
			type: "Unknown",
			typeKey: "Unknown",
			archwing: false,
			sharkwing: false,
			expired: true
		};
		this.steelPath = new SteelPathOfferings(deps);
		[this.vaultTrader] = parseArray(VoidTrader, data.PrimeVaultTraders, deps);
		[this.archonHunt] = parseArray(Sortie, data.LiteSorties, deps);
		const choices = parseArray(DuviriChoice, data.EndlessXpChoices, deps);
		this.duviriCycle = new DuviriCycle(choices);
		[this.calendar] = parseArray(Calendar, data.KnownCalendarSeasons, deps);
		({deepArchimedea: this.deepArchimedea, kinepage: this.kinepage, sentientOutposts: this.sentientOutposts, temporalArchimedea: this.temporalArchimedea} = new Tmp(data.Tmp, deps));
	}
};
var WorldState_default = async (json, deps) => WorldState.build(json, deps);

//#endregion
export { WorldState, WorldState_default, parseArray, parseAsyncArray };