import { Reward } from "./Reward-OauJ45jJ.js";
import { WorldstateObject } from "./WorldstateObject-BSTYuZwm.js";
import { SyndicateJob } from "./SyndicateJob-BK7OMLmv.js";
import { faction, fromNow, languageString, node, parseDate, syndicate } from "warframe-worldstate-data/utilities";

//#region lib/models/WorldEvent.ts
/**
* Represents an in-game special event
* @augments {WorldstateObject}
*/
var WorldEvent = class WorldEvent extends WorldstateObject {
	jobs;
	previousJobs;
	/**
	* The event's main score goal
	*/
	maximumScore;
	/**
	* The current score on the event
	*/
	currentScore;
	/**
	* The first intermediate score goal
	*/
	smallInterval;
	/**
	* The second intermediate score goal
	*/
	largeInterval;
	/**
	* The faction that the players must fight in the event
	*/
	faction;
	/**
	* The description of the event
	*/
	description;
	/**
	* Tooltip for the event
	*/
	tooltip;
	/**
	* The node where the event takes place
	*/
	node;
	/**
	* The other nodes where the event takes place
	*/
	concurrentNodes;
	/**
	* The victim node
	*/
	victimNode;
	/**
	* The score description
	*/
	scoreLocTag;
	/**
	* The event's rewards
	*/
	rewards;
	/**
	* Health remaining for the target
	*/
	health;
	/**
	* Previous job id
	*/
	previousId;
	/**
	* Array of steps
	*/
	interimSteps;
	/**
	* Progress Steps, if any are present
	*/
	progressSteps;
	/**
	* Total of all MultiProgress
	*/
	progressTotal;
	/**
	* Whether to show the total score at the end of the mission
	*/
	showTotalAtEndOfMission;
	/**
	* Whether the event is personal
	*/
	isPersonal;
	/**
	* Whether the event is community
	*/
	isCommunity;
	regionDrops;
	/**
	* Archwing Drops in effect while this event is active
	*/
	archwingDrops;
	/**
	* Metadata provided by DE
	*/
	metadata;
	/**
	* Bonuses given for completion
	*/
	completionBonuses;
	scoreVar;
	altExpiry;
	altActivation;
	nextAlt;
	affiliatedWith;
	/**
	* The event's tag
	*/
	tag;
	victim;
	/**
	* Asynchronously build a new WorldEvent
	* @param data The event data
	* @param deps The dependencies object
	* @returns The created WorldEvent object
	*/
	static async build(data, deps) {
		const event = new WorldEvent(data, deps);
		if (data.Jobs) {
			const jobs = [];
			for await (const job of data.Jobs ?? []) jobs.push(await SyndicateJob.build(job, event.expiry, deps));
			event.jobs = jobs;
		}
		if (data.PreviousJobs) {
			const previousJobs = [];
			for await (const job of data.PreviousJobs ?? []) previousJobs.push(await SyndicateJob.build(job, event.expiry, deps));
			event.previousJobs = previousJobs;
		}
		return event;
	}
	/**
	* @param data The event data
	* @param deps The dependencies object
	*/
	constructor(data, { locale = "en" } = { locale: "en" }) {
		super(data);
		const opts = { locale };
		this.maximumScore = Number.parseInt(String(data.Goal), 10);
		this.currentScore = Number.parseInt(String(data.Count), 10);
		this.smallInterval = Number.parseInt(String(data.GoalInterim), 10);
		this.largeInterval = Number.parseInt(String(data.GoalInterim2), 10);
		this.faction = data.Faction ? faction(data.Faction, locale) : void 0;
		this.description = languageString(data.Desc, locale);
		this.tooltip = data.ToolTip ? languageString(data.ToolTip, locale) : void 0;
		this.node = data.Node ? node(data.Node, locale) : void 0;
		this.concurrentNodes = data.ConcurrentNodes ? data.ConcurrentNodes.map((n) => node(n, locale)) : [];
		this.victimNode = data.VictimNode ? node(data.VictimNode, locale) : void 0;
		this.scoreLocTag = data.ScoreLocTag ? languageString(data.ScoreLocTag, locale) : void 0;
		if (data.Fomorian) this.scoreLocTag = "Fomorian Assault Score";
		this.rewards = Object.keys(data).filter((k) => k.includes("Reward") || k.includes("reward")).map((k) => new Reward(data[k], opts)).filter((r) => r.items.length > 0);
		this.health = typeof data.HealthPct !== "undefined" ? Number.parseFloat(((data.HealthPct || 0) * 100).toFixed(2)) : void 0;
		this.jobs = [];
		this.previousJobs = [];
		this.previousId = data.JobPreviousVersion?.$oid;
		this.interimSteps = [];
		(data.InterimRewards || []).forEach((reward, index) => {
			const msg = (data.InterimRewardMessages || [])[index] || {};
			this.interimSteps[index] = {
				goal: Number.parseInt(String(data.InterimGoals[index]), 10),
				reward: reward ? new Reward(reward, opts) : void 0,
				message: {
					sender: languageString(msg.sender, locale),
					subject: languageString(msg.subject, locale),
					message: languageString(msg.message, locale),
					senderIcon: msg.senderIcon,
					attachments: msg.attachments
				},
				winnerCount: (data._interimWinnerCounts || [])[index]
			};
		});
		this.progressSteps = [];
		if (data.IsMultiProgress) {
			data.Types?.forEach((type, index) => {
				this.progressSteps[index] = {
					type: languageString(type, locale),
					progressAmt: Number.parseInt(String(data.MultiProgress[index]), 10)
				};
			});
			this.progressTotal = Number.parseFloat(data.MultiProgress.reduce((accumulator, val) => accumulator + val));
		}
		this.showTotalAtEndOfMission = data.ShowTotalAtEOM ?? false;
		this.isPersonal = data.Personal;
		this.isCommunity = data.Community ?? false;
		this.regionDrops = (data.RegionDrops || []).map((drop) => languageString(drop, locale));
		this.archwingDrops = (data.ArchwingDrops || []).map((drop) => languageString(drop, locale));
		this.metadata = JSON.parse((data.Metadata || "{}").replace("\" ", "\""));
		this.completionBonuses = data.CompletionBonus || [];
		this.scoreVar = data.ScoreVar;
		this.altExpiry = parseDate(data.AltExpiry);
		this.altActivation = parseDate(data.AltActivation);
		this.nextAlt = {
			expiry: parseDate(data.NextAltExpiry),
			activation: parseDate(data.NextAltActivation)
		};
		if (data.JobAffiliationTag) this.affiliatedWith = syndicate(data.JobAffiliationTag, locale);
		this.tag = data.Tag;
	}
	/**
	* Whether the event has expired
	*/
	get expired() {
		return fromNow(this.expiry) < 0;
	}
};

//#endregion
export { WorldEvent };