name: Update Warframe Public Export JSONs

on:
  schedule:
    - cron: "0 */6 * * *"   # toutes les 6h
  workflow_dispatch:        # lancement manuel

permissions:
  contents: write

concurrency:
  group: warframe-exports
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Write fetch script (your code + tiny --index option)
        run: |
          mkdir -p tools data
          cat > tools/fetch_wf_exports.py <<'PY'
          #!/usr/bin/env python3
          import argparse, lzma, urllib.request, pathlib, sys

          ORIGIN_INDEX = "https://origin.warframe.com/PublicExport/index_{lang}.txt.lzma"
          CONTENT_ROOT = "http://content.warframe.com/PublicExport/Manifest/"

          ASSETS = {
              "companions":   "ExportSentinels_{lang}.json",
              "warframes":    "ExportWarframes_{lang}.json",
              "weapons":      "ExportWeapons_{lang}.json",
              "upgrades":     "ExportUpgrades_{lang}.json",
              "relicarcanes": "ExportRelicArcane_{lang}.json",
              "resources":    "ExportResources_{lang}.json",
              "customs":      "ExportCustoms_{lang}.json",
              "gear":         "ExportGear_{lang}.json",
              "regions":      "ExportRegions_{lang}.json",
              "recipes":      "ExportRecipes_{lang}.json",
              "flavour":      "ExportFlavour_{lang}.json",
              "sortierewards":"ExportSortieRewards_{lang}.json",
              "fullimages":   "ExportManifest.json",
              "drones": "ExportDrones_{lang}.json",
              "fusionbundles": "ExportFusionBundles_{lang}.json"
          }

          def http_get(url: str) -> bytes:
              req = urllib.request.Request(url, headers={
                  "User-Agent": "Mozilla/5.0 (Actions Bot); WarframeExport",
                  "Accept": "*/*",
                  "Accept-Encoding": "gzip, deflate, br",
              })
              with urllib.request.urlopen(req) as r:
                  return r.read()

          def fetch_index(lang: str, index_file: str | None = None) -> str:
              if index_file:
                  return pathlib.Path(index_file).read_text(encoding="utf-8")
              raw = http_get(ORIGIN_INDEX.format(lang=lang))
              try:
                  txt = lzma.decompress(raw).decode("utf-8", "replace")
              except lzma.LZMAError as e:
                  sys.exit(f"Failed to decompress index: {e}")
              return txt

          def find_hashed_url(index_txt: str, asset_basename: str) -> str:
              target_prefix = asset_basename + "!"
              for line in index_txt.splitlines():
                  if line.startswith(target_prefix):
                      return CONTENT_ROOT + line.strip()
              raise SystemExit(f"Asset not found in index: {asset_basename}")

          def save(url: str, out_path: pathlib.Path):
              data = http_get(url)
              out_path.parent.mkdir(parents=True, exist_ok=True)
              out_path.write_bytes(data)
              print(f"✓ Saved {out_path} ({len(data):,} bytes)")

          def main():
              p = argparse.ArgumentParser(description="Fetch Warframe Public Export JSONs")
              p.add_argument("what", nargs="+", help="what to fetch (e.g. companions) or 'all'")
              p.add_argument("-l", "--lang", default="en", help="language code (default: en)")
              p.add_argument("-o", "--out", default=".", help="output directory")
              p.add_argument("--index", help="path to pre-fetched index.txt (optional)")
              args = p.parse_args()

              want = list(ASSETS.keys()) if "all" in args.what else args.what
              unknown = [w for w in want if w not in ASSETS]
              if unknown:
                  sys.exit(f"Unknown asset key(s): {', '.join(unknown)}\nValid: {', '.join(ASSETS)}")

              index_txt = fetch_index(args.lang, args.index)
              out_dir = pathlib.Path(args.out)

              for key in want:
                  basename = ASSETS[key].format(lang=args.lang)
                  url = find_hashed_url(index_txt, basename)
                  # keep hashed filename (we’ll rename after)
                  fname = url.rsplit("/", 1)[1]
                  save(url, out_dir / fname)

          if __name__ == "__main__":
              main()
          PY
          chmod +x tools/fetch_wf_exports.py

      - name: Download index (origin → content fallback)
        run: |
          set -e
          UA="Mozilla/5.0 (Actions Bot); WarframeExport"
          URL_ORIGIN="https://origin.warframe.com/PublicExport/index_en.txt.lzma"
          URL_CONTENT="https://content.warframe.com/PublicExport/index_en.txt.lzma"

          echo "Trying origin…"
          if ! curl -fsSL -A "$UA" --retry 5 --retry-all-errors "$URL_ORIGIN" -o index_en.txt.lzma; then
            echo "Origin blocked (likely 403). Trying content CDN…"
            curl -fsSL -A "$UA" --retry 5 --retry-all-errors "$URL_CONTENT" -o index_en.txt.lzma
          fi

          python - <<'PY'
          import lzma, sys, pathlib
          raw = pathlib.Path("index_en.txt.lzma").read_bytes()
          pathlib.Path("index_en.txt").write_bytes(lzma.decompress(raw))
          print("Index decompressed → index_en.txt")
          PY

      - name: Fetch all exports with your script (using the downloaded index)
        run: |
          python tools/fetch_wf_exports.py all -l en -o data --index index_en.txt

      - name: Rename hashed files to stable basenames
        run: |
          shopt -s nullglob
          for f in data/*.json\!00_*; do
            base="${f%%!00_*}"
            mv "$f" "$base"
            echo "→ $f  ==>  $base"
          done

      - name: Commit if changed
        run: |
          git add -A data/
          if git diff --cached --quiet; then
            echo "Aucun changement à committer."
          else
            git config user.name  "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git commit -m "chore: update PublicExport JSONs ($(date -u +'%Y-%m-%d %H:%M:%S UTC'))"
            git push
          fi
