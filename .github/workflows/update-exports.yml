name: Update Warframe Public Export JSONs

on:
  schedule:
    - cron: "0 */6 * * *"   # toutes les 6h
  workflow_dispatch:        # lancement manuel

permissions:
  contents: write

concurrency:
  group: warframe-exports
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      # -------------------- PYTHON : FETCH PUBLIC EXPORT --------------------
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Write fetch script (index → hashed → files)
        run: |
          mkdir -p tools data
          cat > tools/fetch_wf_exports.py <<'PY'
          #!/usr/bin/env python3
          import argparse, lzma, urllib.request, pathlib, sys

          ORIGIN_INDEX = "https://origin.warframe.com/PublicExport/index_{lang}.txt.lzma"
          CONTENT_ROOT = "http://content.warframe.com/PublicExport/Manifest/"

          ASSETS = {
              "companions":   "ExportSentinels_{lang}.json",
              "warframes":    "ExportWarframes_{lang}.json",
              "weapons":      "ExportWeapons_{lang}.json",
              "upgrades":     "ExportUpgrades_{lang}.json",
              "relicarcanes": "ExportRelicArcane_{lang}.json",
              "resources":    "ExportResources_{lang}.json",
              "customs":      "ExportCustoms_{lang}.json",
              "gear":         "ExportGear_{lang}.json",
              "regions":      "ExportRegions_{lang}.json",
              "recipes":      "ExportRecipes_{lang}.json",
              "flavour":      "ExportFlavour_{lang}.json",
              "sortierewards":"ExportSortieRewards_{lang}.json",
              "fullimages":   "ExportManifest.json",
              "drones":       "ExportDrones_{lang}.json",
              "fusionbundles":"ExportFusionBundles_{lang}.json"
          }

          def http_get(url: str) -> bytes:
              req = urllib.request.Request(url, headers={
                  "User-Agent": "Mozilla/5.0 (Actions Bot); WarframeExport",
                  "Accept": "*/*",
                  "Accept-Encoding": "gzip, deflate, br",
              })
              with urllib.request.urlopen(req) as r:
                  return r.read()

          def fetch_index(lang: str, index_file: str | None = None) -> str:
              if index_file:
                  return pathlib.Path(index_file).read_text(encoding="utf-8")
              raw = http_get(ORIGIN_INDEX.format(lang=lang))
              try:
                  txt = lzma.decompress(raw).decode("utf-8", "replace")
              except lzma.LZMAError as e:
                  sys.exit(f"Failed to decompress index: {e}")
              return txt

          def find_hashed_url(index_txt: str, asset_basename: str) -> str:
              target_prefix = asset_basename + "!"
              for line in index_txt.splitlines():
                  if line.startswith(target_prefix):
                      return CONTENT_ROOT + line.strip()
              raise SystemExit(f"Asset not found in index: {asset_basename}")

          def save(url: str, out_path: pathlib.Path):
              data = http_get(url)
              out_path.parent.mkdir(parents=True, exist_ok=True)
              out_path.write_bytes(data)
              print(f"✓ Saved {out_path} ({len(data):,} bytes)")

          def main():
              p = argparse.ArgumentParser(description="Fetch Warframe Public Export JSONs")
              p.add_argument("what", nargs="+", help="what to fetch (e.g. companions) or 'all'")
              p.add_argument("-l", "--lang", default="en", help="language code (default: en)")
              p.add_argument("-o", "--out", default=".", help="output directory")
              p.add_argument("--index", help="path to pre-fetched index.txt (optional)")
              args = p.parse_args()

              want = list(ASSETS.keys()) if "all" in args.what else args.what
              unknown = [w for w in want if w not in ASSETS]
              if unknown:
                  sys.exit(f"Unknown asset key(s): {', '.join(unknown)}\nValid: {', '.join(ASSETS)}")

              index_txt = fetch_index(args.lang, args.index)
              out_dir = pathlib.Path(args.out)

              for key in want:
                  basename = ASSETS[key].format(lang=args.lang)
                  url = find_hashed_url(index_txt, basename)
                  fname = url.rsplit("/", 1)[1]  # keep hashed filename (we’ll rename after)
                  save(url, out_dir / fname)

          if __name__ == "__main__":
              main()
          PY
          chmod +x tools/fetch_wf_exports.py

      - name: Download index (origin → content fallback)
        run: |
          set -e
          UA="Mozilla/5.0 (Actions Bot); WarframeExport"
          O="https://origin.warframe.com/PublicExport/index_en.txt.lzma"
          C="https://content.warframe.com/PublicExport/index_en.txt.lzma"
          echo "Trying origin…"
          if ! curl -fsSL -A "$UA" --retry 5 --retry-all-errors "$O" -o index_en.txt.lzma; then
            echo "Origin blocked. Trying content CDN…"
            curl -fsSL -A "$UA" --retry 5 --retry-all-errors "$C" -o index_en.txt.lzma
          fi
          python - <<'PY'
          import lzma, pathlib
          raw = pathlib.Path("index_en.txt.lzma").read_bytes()
          pathlib.Path("index_en.txt").write_bytes(lzma.decompress(raw))
          print("Index decompressed → index_en.txt")
          PY

      - name: Fetch all exports with your script (using the downloaded index)
        run: python tools/fetch_wf_exports.py all -l en -o data --index index_en.txt

      - name: Rename hashed files to stable basenames
        run: |
          shopt -s nullglob
          for f in data/*.json\!00_*; do
            base="${f%%!00_*}"
            mv "$f" "$base"
            echo "→ $f  ==>  $base"
          done

      # -------------------- PYTHON : TON SCRIPT DE DROPS --------------------
      - name: Install Python deps for drop parser
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4

      - name: Fetch drop data via repo script
        run: |
          mkdir -p data
          python tools/fetch_drop_data.py --output data/drops_all.slim.wfcd.json

      # -------------------- NODE : WFCD DATASETS (*.wfcd.json) --------------------
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install WFCD deps (no-save)
        run: npm install --no-save @wfcd/items@latest warframe-patchlogs@latest

      - name: Write build_items.js (WFCD → data/*.wfcd.json)
        run: |
          mkdir -p tools
          cat > tools/build_items.js <<'JS'
          /* eslint-disable no-console */
          import { mkdir, writeFile } from 'node:fs/promises';
          import { resolve } from 'node:path';
          import Items from '@wfcd/items';

          const OUT = 'data'; // on regroupe tout dans data/
          const FN = {
            warframes: 'warframes.wfcd.json',
            weapons:   'weapons.wfcd.json',
            mods:      'mods.wfcd.json',
            arcanes:   'arcanes.wfcd.json',
            companions:'companions.wfcd.json',
            relics:    'relics.wfcd.json',
            unified:   'items.unified.wfcd.json', // optionnel
          };

          const keep = (obj, keys) => Object.fromEntries(
            Object.entries(obj).filter(([k]) => keys.includes(k))
          );

          function normalizeWarframe(i) {
            const base = keep(i, [
              'name','uniqueName','type','health','shield','armor','power','stamina',
              'polarities','aura','exilus','description','wikiaUrl','color'
            ]);
            if (Array.isArray(i.abilities)) {
              base.abilities = i.abilities.map(a => keep(a, ['name','description']));
            }
            if (i.helminth?.name) base.helminthAbility = keep(i.helminth, ['name','description']);
            if (Array.isArray(i.drops) && i.drops.length)
              base.drops = i.drops.map(d => keep(d, ['location','rarity','chance']));
            if (Array.isArray(i.patchlogs) && i.patchlogs.length)
              base.patchlogs = i.patchlogs.map(p => keep(p, ['name','date','url','additions']));
            return base;
          }

          function normalizeWeapon(i) {
            const base = keep(i, [
              'name','uniqueName','type','category','slot','masteryReq',
              'damage','damagePerShot','totalDamage','critChance','critMult',
              'statusChance','fireRate','magazineSize','reloadTime',
              'polarities','description','wikiaUrl','color'
            ]);
            if (Array.isArray(i.drops) && i.drops.length)
              base.drops = i.drops.map(d => keep(d, ['location','rarity','chance']));
            if (Array.isArray(i.patchlogs) && i.patchlogs.length)
              base.patchlogs = i.patchlogs.map(p => keep(p, ['name','date','url','additions']));
            return base;
          }

          function normalizeMod(i) {
            const base = keep(i, [
              'name','uniqueName','type','rarity','polarity','baseDrain',
              'fusionLimit','compatName','description','wikiaUrl'
            ]);
            if (Array.isArray(i.levelStats)) base.levelStats = i.levelStats;
            if (Array.isArray(i.drops) && i.drops.length)
              base.drops = i.drops.map(d => keep(d, ['location','rarity','chance']));
            return base;
          }

          function normalizeGeneric(i) {
            const base = keep(i, ['name','uniqueName','type','category','description','wikiaUrl']);
            if (Array.isArray(i.drops) && i.drops.length)
              base.drops = i.drops.map(d => keep(d, ['location','rarity','chance']));
            return base;
          }

          async function main() {
            const items = new Items().items;

            const warframes = items.filter(i => i.category === 'Warframes').map(normalizeWarframe);
            const weapons   = items.filter(i => ['Primary','Secondary','Melee','Arch-Gun','Arch-Melee','Crewship Weapon']
                                                .includes(i.category)).map(normalizeWeapon);
            const mods      = items.filter(i => i.category === 'Mods').map(normalizeMod);
            const arcanes   = items.filter(i => i.category === 'Arcanes').map(normalizeGeneric);
            const companions= items.filter(i => ['Companions','Sentinels','Beasts'].includes(i.category))
                                   .map(normalizeGeneric);
            const relics    = items.filter(i => i.category === 'Relics').map(normalizeGeneric);

            await mkdir(OUT, { recursive: true });

            const writes = [
              [FN.warframes,  warframes],
              [FN.weapons,    weapons],
              [FN.mods,       mods],
              [FN.arcanes,    arcanes],
              [FN.companions, companions],
              [FN.relics,     relics],
              [FN.unified,    items], // optionnel
            ].map(async ([file, data]) => {
              await writeFile(resolve(OUT, file), JSON.stringify(data, null, 2), 'utf-8');
              console.log(`✔ ${OUT}/${file}`, data.length);
            });

            await Promise.all(writes);
          }

          main().catch(err => { console.error(err); process.exit(1); });
          JS

      - name: Build WFCD datasets (*.wfcd.json)
        run: node tools/build_items.js

      # -------------------- COMMIT UNIQUE DE TOUT data/ --------------------
      - name: Commit data if changed
        run: |
          git add -A data/
          if git diff --cached --quiet; then
            echo "Aucun changement à committer."
          else
            git config user.name  "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git commit -m "chore: update data (PublicExport + Drops + WFCD) ($(date -u +'%Y-%m-%d %H:%M:%S UTC'))"
            git push
          fi
